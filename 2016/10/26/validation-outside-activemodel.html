<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta content="IE=edge;chrome=1" http-equiv="X-UA-Compatible" /><title>Validation outside ActiveModel - Ragnarson Blog</title><meta content="summary" name="twitter:card" /><meta content="@ragnarsoncom" name="twitter:site" /><meta content="Ragnarson Blog" property="og:site_name" /><meta content="article" property="og:type" /><meta content="https://blog.ragnarson.com/2016/10/26/validation-outside-activemodel.html" property="og:url" /><meta content="Validation outside ActiveModel" property="og:title" /><meta content="On the latest Euruko Ruby Conference (Bulgaria, Sofia, 2016) I had a lightning talk about a different approach to data verification. Today, I want to share and explain more of the good stuff in validation.

In a Ruby on Rails application, we use validation..." property="og:description" /><meta content="Krzysztof Wawer" name="author" /><meta content="https://blog.ragnarson.com/2016/10/26/validation-outside-activemodel/cover-c0793870f1.jpg" property="og:image" /><link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" /><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css" /><link href="https://fonts.googleapis.com/css?family=Lato:400,700&subset=latin,latin-ext" rel="stylesheet" type="text/css" /><script type="application/ld+json">{"@context":"http://schema.org","@type":"Organization","name":"Ragnarson","url":"https://ragnarson.com"}</script><script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","name":"Ragnarson Blog","url":"https://blog.ragnarson.com"}</script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Person","name":"Krzysztof Wawer","image":"https://www.gravatar.com/avatar/01ec9a945ae5bb0e2a776740d0d19aaf.jpg?s=144&d=mm"}</script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","headline":"Validation outside ActiveModel","url":"https://blog.ragnarson.com/2016/10/26/validation-outside-activemodel.html","author":{"@type":"Person","name":"Krzysztof Wawer","image":"https://www.gravatar.com/avatar/01ec9a945ae5bb0e2a776740d0d19aaf.jpg?s=144&d=mm"},"publisher":{"@type":"Organization","name":"Ragnarson","url":"https://ragnarson.com","logo":"https://blog.ragnarson.com/images/brand-c0054f1cec.svg"},"datePublished":"2016-10-26","dateModified":"2016-10-26","image":"https://blog.ragnarson.com/2016/10/26/validation-outside-activemodel/cover-c0793870f1.jpg"}</script><meta content="width=device-width, initial-scale=1.0" name="viewport" /><link href="/stylesheets/application-c0f3339569.css" rel="stylesheet" /><link href="/favicon-152-c0fe5a334d.png" rel="apple-touch-icon-precomposed" /><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-11839548-2');
ga('set', 'allowAdFeatures', false);
ga('set', 'anonymizeIp', true);
ga('send', 'pageview');
</script>
</head><body><div class="container nav-container"><nav class="navbar navbar-dark navbar-toggleable-md"><button aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" data-target="#navbarResponsive" data-toggle="collapse" type="button"><i class="icon-menu"></i></button><a href="https://ragnarson.com" class="nav-brand navbar-logo"><img src="/images/brand-c0054f1cec.svg" title="Ragnarson Blog" width="220px" alt="Brand" /></a><div class="collapse navbar-collapse" id="navbarResponsive"><ul class="nav navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">Why us</a><div class="dropdown-menu"><a href="https://ragnarson.com/manifesto" class="dropdown-item">Manifesto</a><a href="https://ragnarson.com/team" class="dropdown-item">Team</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">Services</a><div class="dropdown-menu"><a href="https://ragnarson.com/software-development" class="dropdown-item">Software Development</a><a href="https://ragnarson.com/fund" class="dropdown-item">Fund</a><a href="https://ragnarson.com/advisory" class="dropdown-item">Advisory</a></div></li><li class="nav-item"><a href="https://ragnarson.com/case-studies" class="nav-link">Case studies</a></li><li class="nav-item"><a href="https://ragnarson.com/?utm_source=ragnarson&amp;utm_medium=blog&amp;utm_campaign=blog-header#the-contact-form" class="nav-link">Contact</a></li><li class="nav-item"><a href="/" class="active nav-link">Blog</a></li><li class="nav-item"><a href="https://ragnarson.com/careers" class="nav-link">Careers</a></li></ul></div></nav></div><div class="newsletter-show newsletter-container" id="js-box"><div class="newsletter-toggler"><i class="icon-chevron-right" id="js-arrow"></i></div><div class="newsletter-box"><div class="newsletter-popup"><div id="mc_embed_signup">
  <form action="//ragnarson.us10.list-manage.com/subscribe/post?u=6a4a4d00f989604300f83d3de&amp;id=6adadf2f44" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <div id="mc_embed_signup_scroll">
      <label for="mce-EMAIL" class="newsletter-label">
        Sign up for our newsletter and get notifications about new articles on your email
      </label>

      <div class="row">
        <div class="three-thirds">
          <input type="email" value="" name="EMAIL" class="newsletter-input" id="mce-EMAIL" placeholder="Your email address" required>

          <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
          <div class="signup_hidden">
            <input type="text" name="b_6a4a4d00f989604300f83d3de_6adadf2f44" tabindex="-1" value="" class="one-half">
          </div>
        </div>

        <div class="mt-3 text-center">
          <input type="submit" value="Join our newsletter" name="subscribe" id="mc-embedded-subscribe" class="btn newsletter-btn">
        </div>
      </div>
    </div>
  </form>
</div>
</div></div></div><div id="main" role="main"><div class="article"><header><img src="https://www.gravatar.com/avatar/01ec9a945ae5bb0e2a776740d0d19aaf.jpg?s=144&amp;d=mm" class="avatar" width="72px" size="72px" alt="01ec9a945ae5bb0e2a776740d0d19aaf" /><div class="article-meta">October 26, 2016 - <a href="/authors/krzysztof-wawer.html">Krzysztof Wawer</a>  in <a href="/categories/development.html">development</a></div><h1 class="article-title"><a href="/2016/10/26/validation-outside-activemodel.html">Validation outside ActiveModel</a></h1></header><img src='/2016/10/26/validation-outside-activemodel/cover-c0793870f1.jpg'/><p>On the latest Euruko Ruby Conference (Bulgaria, Sofia, 2016) I had a lightning talk about a different approach to data verification. Today, I want to share and explain more of the good stuff in validation.</p>

<p>In a Ruby on Rails application, we use validation mostly for models:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>

<p>or forms:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserForm</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Model</span>

  <span class="kp">attr_accessor</span> <span class="ss">:name</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre>

<p>There are cases when the application isn&#39;t saving data in any database, nor is any data received from a form on a web page, but we still need to perform validations. One example could be sending SMS - before we do it, we need to make sure we&#39;re sending correct data.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserContact</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Validations</span>

  <span class="kp">attr_accessor</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:phone_number</span><span class="p">,</span> <span class="ss">:message</span>

  <span class="n">validates</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
  <span class="n">validates</span> <span class="ss">:phone_number</span><span class="p">,</span> <span class="ss">numericality: </span><span class="p">{</span> <span class="ss">only_integer: </span><span class="kp">true</span> <span class="p">}</span>
  <span class="n">validates</span> <span class="ss">:message</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
<span class="k">end</span>

<span class="n">contact</span> <span class="o">=</span> <span class="no">UserContact</span><span class="p">.</span><span class="nf">new</span>
<span class="n">contact</span><span class="p">.</span><span class="nf">name</span> <span class="o">=</span> <span class="s2">"John Doe"</span>
<span class="n">contact</span><span class="p">.</span><span class="nf">phone_number</span> <span class="o">=</span> <span class="mi">123456789</span>
<span class="n">contact</span><span class="p">.</span><span class="nf">valid?</span> <span class="c1"># =&gt; false</span>
<span class="n">contact</span><span class="p">.</span><span class="nf">errors</span> <span class="c1"># =&gt; { message: ["can't be blank"] }</span>
</code></pre>

<h2>Validating without Rails</h2>

<p>For one of our clients, we have decided to build a single page application with API without using Ruby on Rails. This approach allowed us to decrease response time from API. We used Roda for routing, ROM (Ruby Object Mapper) as an access layer to the database and dry-validation for validation.</p>

<p>ROM is a small layer between a database adapter and application. ROM doesn&#39;t have validation layer. We used dry-validation gem which provides a lot of fancy validation rules.</p>

<p>Dry-validation is designed to validate any data stored in a hash. It forces us to focus on input data more carefully when validating model attributes. On the other hand, it makes us more aware of the input data.</p>

<h2>Invoking a validation</h2>

<p>Validation in dry-validation gem looks a bit different than model oriented validation.</p>
<pre class="highlight ruby"><code><span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
  <span class="ss">phone_number: </span><span class="mi">123456789</span>
<span class="p">}</span>

<span class="no">UserContactSchema</span> <span class="o">=</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:phone_number</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="o">&amp;</span> <span class="kp">nil</span><span class="p">?</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">result</span> <span class="o">=</span> <span class="no">UserContactSchema</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
<span class="n">result</span><span class="p">.</span><span class="nf">success?</span> <span class="c1"># =&gt; true</span>
<span class="n">result</span><span class="p">.</span><span class="nf">failure?</span> <span class="c1"># =&gt; false</span>
<span class="n">result</span><span class="p">.</span><span class="nf">errors</span> <span class="c1"># =&gt; { message: ["must be filled"] }</span>
</code></pre>

<p>In dry-validation, we can also write</p>
<pre class="highlight ruby"><code><span class="n">required</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">filled</span>
</code></pre>

<p>which is equal to</p>
<pre class="highlight ruby"><code><span class="n">required</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
</code></pre>

<h2>Optional key and value</h2>

<p>In models, we predefine attributes in class implementation. We make sure that object will have a filled attribute or an attribute with nil value. In a hash, we have a little more complicated situation, a key can be set or not. Firstly, take a look on hash without name key:</p>
<pre class="highlight ruby"><code><span class="p">{</span>
  <span class="ss">age: </span><span class="mi">30</span>
<span class="p">}</span>
</code></pre>

<p>Let&#39;s write validation rules:</p>
<pre class="highlight ruby"><code><span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:age</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="o">&amp;</span> <span class="n">int?</span> <span class="o">&amp;</span> <span class="n">gt?</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Now, we will extend hash with name key:</p>
<pre class="highlight ruby"><code><span class="p">{</span>
  <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
  <span class="ss">age: </span><span class="mi">30</span>
<span class="p">}</span>
</code></pre>

<p>New validation schema should handle optional key:</p>
<pre class="highlight ruby"><code><span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">optional</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:age</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="o">&amp;</span> <span class="n">int?</span> <span class="o">&amp;</span> <span class="n">gt?</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Sometimes, when data is sent from the outside world it can contain nil value. For example, someone uses a model-based framework and the application sends keys without values.</p>
<pre class="highlight ruby"><code><span class="p">{</span>
  <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
  <span class="ss">age: </span><span class="kp">nil</span>
<span class="p">}</span>
</code></pre>

<p>When we decide to allow nil value for some attributes we must handle it in schema:</p>
<pre class="highlight ruby"><code><span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">optional</span><span class="p">(</span><span class="ss">:name</span><span class="p">}</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:age</span><span class="p">)</span> <span class="p">{</span> <span class="n">none?</span> <span class="o">|</span> <span class="p">(</span><span class="n">filled?</span> <span class="o">&amp;</span> <span class="n">int?</span> <span class="o">&amp;</span> <span class="n">gt?</span><span class="p">(</span><span class="mi">18</span><span class="p">))</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<h2>Nested data</h2>

<p>Let&#39;s go back to our user&#39;s contact hash:</p>
<pre class="highlight ruby"><code><span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
  <span class="ss">phone_number: </span><span class="mi">123456789</span>
<span class="p">}</span>
</code></pre>

<p>We can assume that data will be sending to API in JSON API standard. In this case, the params will look like this:</p>
<pre class="highlight ruby"><code><span class="p">{</span>
  <span class="ss">data: </span><span class="p">{</span>
    <span class="ss">attributes: </span><span class="p">{</span>
      <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
      <span class="ss">phone_number: </span><span class="mi">123456789</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Schema with attributes nested in hash isn&#39;t so complicated:</p>
<pre class="highlight ruby"><code><span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="nb">require</span><span class="p">(</span><span class="ss">:data</span><span class="p">).</span><span class="nf">schema</span> <span class="k">do</span>
    <span class="nb">require</span><span class="p">(</span><span class="ss">:attributes</span><span class="p">).</span><span class="nf">schema</span> <span class="k">do</span>
      <span class="n">optional</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
      <span class="n">required</span><span class="p">(</span><span class="ss">:phone_number</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="o">&amp;</span> <span class="n">int?</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Next great thing is validating an array:</p>
<pre class="highlight ruby"><code><span class="n">input_data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">data: </span><span class="p">{</span>
    <span class="ss">attributes: </span><span class="p">{</span>
      <span class="ss">name: </span><span class="s2">"John Doe"</span><span class="p">,</span>
      <span class="ss">phone_number: </span><span class="mi">123456789</span><span class="p">,</span>
      <span class="ss">emails: </span><span class="p">[</span><span class="s2">"foobar@example.com"</span><span class="p">,</span> <span class="s2">"foobar"</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>And validation schema:</p>
<pre class="highlight ruby"><code><span class="n">schema</span> <span class="o">=</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="nb">require</span><span class="p">(</span><span class="ss">:data</span><span class="p">).</span><span class="nf">schema</span> <span class="k">do</span>
    <span class="nb">require</span><span class="p">(</span><span class="ss">:attributes</span><span class="p">).</span><span class="nf">schema</span> <span class="k">do</span>
      <span class="n">optional</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="p">}</span>
      <span class="n">required</span><span class="p">(</span><span class="ss">:phone_number</span><span class="p">)</span> <span class="p">{</span> <span class="n">filled?</span> <span class="o">&amp;</span> <span class="n">int?</span> <span class="p">}</span>
      <span class="n">optional</span><span class="p">(</span><span class="ss">:emails</span><span class="p">).</span><span class="nf">each</span><span class="p">(</span><span class="ss">:email?</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">schema</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">input_data</span><span class="p">).</span><span class="nf">message</span>
<span class="c1"># {</span>
<span class="c1">#   emails: {</span>
<span class="c1">#     1 =&gt; ["must be valid email address"]</span>
<span class="c1">#   }</span>
<span class="c1"># }</span>
</code></pre>

<p>NOTICE: In the example above can you see :email? symbol. This symbol will invoke email? predicate which isn&#39;t available in dry-validation. Donâ€™t worry I will show you how to implement your own predicate in the next post. Subscribe to our newsletter and wait for next part.</p>

<h2>Shared schemas</h2>

<p>Sometimes we repeat the same data structure like an address on an invoice, customer address and delivery address. With dry-validation, we can create validation for address and attach it many times.</p>
<pre class="highlight ruby"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">customer_address: </span><span class="p">{</span>
    <span class="ss">street: </span><span class="s2">"Main Street"</span><span class="p">,</span>
    <span class="ss">city: </span><span class="s2">"New York"</span>
  <span class="p">},</span>
  <span class="ss">delivery_address: </span><span class="p">{</span>
    <span class="ss">street: </span><span class="s2">"Brodway"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>We can define only one schema:</p>
<pre class="highlight ruby"><code><span class="no">AddressSchema</span> <span class="o">=</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:street</span><span class="p">).</span><span class="nf">filled</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:city</span><span class="p">).</span><span class="nf">filled</span>
<span class="k">end</span>
</code></pre>

<p>with already prepared schema we can use it twice:</p>
<pre class="highlight ruby"><code><span class="n">invoice_schema</span> <span class="o">=</span> <span class="no">InvoiceSchema</span> <span class="o">=</span> <span class="no">Dry</span><span class="o">::</span><span class="no">Validation</span><span class="o">.</span><span class="no">Schema</span> <span class="k">do</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:customer_address</span><span class="p">).</span><span class="nf">schema</span><span class="p">(</span><span class="no">AddressSchema</span><span class="p">)</span>
  <span class="n">required</span><span class="p">(</span><span class="ss">:delivery_address</span><span class="p">).</span><span class="nf">schema</span><span class="p">(</span><span class="no">AddressSchema</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>Let&#39;s check how it will behave:</p>
<pre class="highlight ruby"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">customer_address: </span><span class="p">{</span>
    <span class="ss">street: </span><span class="s2">"Main Street"</span><span class="p">,</span>
    <span class="ss">city: </span><span class="s2">"New York"</span>
  <span class="p">},</span>
  <span class="ss">delivery_address: </span><span class="p">{</span>
    <span class="ss">street: </span><span class="s2">"Brodway"</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">puts</span> <span class="n">invoice_schema</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="nf">messages</span>
<span class="c1"># {</span>
<span class="c1">#   delivery_address: {</span>
<span class="c1">#     city: ["is missing"]</span>
<span class="c1">#   }</span>
<span class="c1"># }</span>
</code></pre>

<p>If you don&#39;t use ActiveRecord/ActiveModel/Ruby on Rails or you need to verify something different than a class with attributes, you should try dry-validation.</p>
<div class="work-with-us"><p>At Ragnarson we help companies deliver great products. We take care of development and deployment so that they can focus on growing the product and working with customers.</p><a class="btn" href="https://ragnarson.com/?utm_source=ragnarson&utm_medium=blog&utm_campaign=work-with-us#contact">Work with us</a></div><div class="article-comments"><div id="commento"></div>
<script src="https://cdn.commento.io/js/commento.js"></script>
</div></div><footer><div class="text--center"><a href="https://ragnarson.com/?utm_source=ragnarson&amp;utm_medium=blog&amp;utm_campaign=blog-footer"><img src="/images/ragnar-desk-c0d025368e.png" srcset="/images/ragnar-desk-c0d025368e.png 1x, /images/ragnar-desk-2x-c0332b062e.png 2x" alt="Ragnar desk" /></a></div></footer></div><script src="/javascripts/application-c0ec307bf9.js"></script></body></html>